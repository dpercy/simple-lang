
Some ideas about a different VM.

Problem: direct-style JS has a tiny stack
- structural recursion on lists is way too limited

WebAssembly would be neat.
problem: only supports flat bytes


Another approach is to compile to a stack-machine in JS.


Some work they have in common: define a bytecode format.
The bytecode can closely mirror the core syntax:
- rely on tail calls for loops and joins
- one opcode for Call
- unsafe function struct-ref
- 2-way if on booleans
  - no match/switch, because my match-switch can be dynamic
    - can try that later

so the steps are:
- desugar Match to If + struct-ref
- let-bind every intermediate value (ANF?)
- replace names with numbers
- compile to bytecode?


instruction :=
(push-quoted v)
(push-global mod name)
(crash msg)
(if/goto ref offset)
(call ref ref ...)
(return ref)
(tailcall ref ref ...)

or as expressions:

expression :=
(let-quoted v expr)
(let-global mod name expr)
(crash msg)
(if ref expr expr)
(let-call ref [ref ...] expr)
(return ref)
(tailcall ref [ref ...])


btw might be easier to let refs be like register numbers,
NOT like de bruijn indices.

Remember to keep the control stack *off* the native stack.
The whole point of this VM is to remove artificial limits on recursion.

Having an explicit stack might make delimited control much more efficient!
You can copy the stack instead of CPSing all the code.