
<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.30.0/codemirror.css">
<style>
  body {
    margin: 0;
    padding: 0;
  }
  body > .CodeMirror {
    width: 100%;
    height: 100%;
    margin: 0;
  }
  
  pre.output {
    display: inline-block;
    border: 1px solid #214182;
    border-radius: 3px;
    background-color: #edf3ff;
  }

  pre.output.error {
    background-color: #ffeaea;
    border-color: #8e4848;
  }
</style>


<textarea id="myTextarea">

// Try changing to your name
name = 'world';

greeting = 'hello, ' + name + '!';


// define and use a function
fact = function fact(n) { if (n < 1) { return 1 } else { return n * fact(n-1) } }
fact(4)


// define a function and test it immediately
fb = n => !(n%3)?'fizz' : !(n%5)?'buzz' : !(n%15)?'fizzbuzz' : '';

assertEq(fb(3), 'fizz')
assertEq(fb(4), '')
assertEq(fb(5), 'buzz')
assertEq(fb(6), 'fizz')
// Hm, this case isn't working. Can you spot the bug?
assertEq(fb(15), 'fizzbuzz')

</textarea>




<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.30.0/codemirror.js"></script>
<script>
  (function() {
    var editor = CodeMirror.fromTextArea(myTextarea, {
      lineNumbers: true
    });


    editor.on('change', updateAllLineWidgets);

    const widgets = [];
    function updateAllLineWidgets() {
      // clear all
      for (const widget of widgets.splice(0)) {
	widget.clear();
      }

      // recreate all
      editor.eachLine(line => {
	let text = line.text;
	console.log('update', line, text);

	// preprocess blanks and comments
	if (!text)
	  return;
	text = text.trim();
	if (!text || text.slice(0, 2) === '//')
	  return;
	
	const [value, isError] = evaluate(text);
	
	const elem = document.createElement('pre');
	elem.classList.add('output');
	if (isError) {
	  elem.classList.add('error');
	  elem.innerText = showError(value);
	} else {
	  elem.innerText = showValue(value);
	}

	const widget = editor.addLineWidget(line, elem);
	widgets.push(widget);
      });

    }

    function evaluate(text) {
      try {
	return [eval(text), false];
      } catch(exn) {
	return [exn, true];
      }
    }

    function showValue(value) {
      if (Array.isArray(value)) {
	return '[' + value.map(showValue).join(', ') + ']';
      } else if (typeof value === 'function') {
	return value.toString();
      } else if (typeof value === 'object' && value !== null) {
	let s = '{';
	let sep = ' ';
	for (const key of Object.keys(value)) {
	  s += sep + key + ': ' + showValue(value[key]);
	  sep = ', ';
	}
	if (s !== '{')
	  s += ' ';
	s += '}'
	return s;
      } else {
	// leaf case: defer to json
	return JSON.stringify(value);
      }
    }

    function showError(exn) {
      if (exn instanceof SyntaxError) {
	return exn.toString();
      } else { 
	return exn.stack;
      }
    }

    updateAllLineWidgets();

    function assertEq(x, y) {
      if (x !== y) {
	throw Error(showValue(x) + ' and ' + showValue(y) + ' are not equal');
      }
      return true;
    }


    // publish some global values for debugging
    window.__updateAllLineWidgets = updateAllLineWidgets;
    window.__evaluate = evaluate;
    window.__editor = editor;
    window.__showValue = showValue;
    window.__showError = showError;
    window.assertEq = assertEq;
  })();
</script>
