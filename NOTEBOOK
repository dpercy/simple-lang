
Current most pressing need with the notebook UI:

line numbers. I can't tell which outputs go with which expressions.

impl plan?

- add line numbers to read
- add line numbers to parse
- don't just print the line numbers - that would break all the tests
- don't add new "modes" to codegen

What do you generate for the module?
Different "runtime modes", where some env var determines how to print?

Or maybe the module doesn't run for side effects, but exports some interface
to run the module?


Maybe SL modules should be compiled down to a JS function.
That way the SL runtime has more control.
Also fits the philosophy of "everything is a value".

Its arguments would be the instantiated modules it depends on.
It returns an "instantiated module".
(function ({ bool, list, string }) {

  ...

  return {
    $gen_program,
    $parse_program,
    $read_all,
    ...
  }

});

ok, problems still:
- no incremental progress (YAGNI???)





backing up:
what problem am I solving?
- line numbers
- preserve incremental output
- preserve current behavior of command line tests?
  - or, is it more valuable to change the tests,
    so that line numbers get tested?

Simplest thing that works:
- add line numbers to read, parse
- gen line numbers in calls to "toplevel"
- let primitives.mjs read some global setting, on window, about how to print



================================================================================

I want to solve line numbers without adding tech debt.

The problem is:
the run-time behavior of a module is too fixed.
The .mjs files are too imperative:
they spit out values sequentially to console.log.

I want the compiled .mjs files to assume a bit less.
The runtime system needs more choice over what to do with the module.


At a minimum, the runtime system needs to choose:
- whether defvals get printed
- what to do with line numbers
- what to do with the strings we want to print

Ideally I don't just want to expose a flag.
Maybe I'll expose a hook.
Would be neat to turn it rightside out: yield intermediate results?


================================================================================


Next problem: no results are printed until the whole module terminates.

Web Workers would probably fix this.
But, browsers apparently don't support es6 modules in web workers yet.
So I need to either:
- compile directly to some other format instead of mjs
  - but does any format support both nodejs and browsers?
- use webpack/rollup to convert .mjs to browser files
- use a module loader inside the worker


What if I compiled each definition in a module to a promise?
It's legal to use await inside a promise, so they could just await each other.

(def x (+ 2 3))
(def y (* x x))

=>

const x = new Promise(async function(resolve) { return (  (await import "+")(2, 3)  ) })
const y = new Promise(async function(resolve) { return (  (await import "*")(await x, await x) ); })


pro:
- can use es6 modules
con:
- have to use annoying promises



Another idea:
compile to some dumb format with just JS values,
similar to (identical to?) AMD.

{
    requires: ['thing.sl', 'foo.sl'],
    provides: ['x', 'y'],
    run: function({ thing, foo }) {
        // thing and foo are the *return values* of running that corresponding module.

        const x = toplevel(() => 2 + 3);
        const y = toplevel(() => x * x);
        return { x, y };
    }
}

In this impl, a module is a value.
This might also help with `import *` type of thing.

The "runtime system" would be a separate thing that invokes the `run` method.
verbosity / control




================================================================================


current annoyance?

primitives.<
primitives.=
(primitives.+ (fib (primitives.- n 1)) (fib (primitives.- n 2)))


Why is it like this?
I'm using Java-style fully-qualified names to determine dependencies.
"foo" means (Var "foo")
"prim.foo" means (Global "prim" "foo")


Maybe you can say (using primitives).

So  resolving an identifier  requires  looking up another module's exports.
This seems like a side effect!  (A request to the environment.)

Or, you could say that parsing leaves some identifiers "unresolved".
Resolving them requires a "link" step.
But would you "link" before or after compiling??

It's more intuitive for identifiers to be resolved during parsing.
Also, IDE features like completion require you do list your imports.



Maybe  parse  takes an "env" or "libs" parameter,
which tells it
- whether a given library exists
- what names it exports

Maybe it's just a big list!

(list (Lib "primitives" (list "+" "<" "string-append" ...))
      (Lib "string" (list "slice" "length" ...))
      (Lib "list" (list "slice" "length" ...))
      ...)

- super simple
- easy to print / inspect

Why is this "list" model inadequate?
It assumes you've already ordered all the modules,
so you know which ones are elligible to be used.
In reality you might just have a bag of files.


(What if you break the cycle this way?
1. read
2. parse -> determines exports
3. resolve -> evaluates the using statements, requires only parsing
)

(What if you stop assuming "namespace" == "compilation unit" ?
- "module" would be a semantic concept: a named bundle of definitions.
- compilation strategy is layered on top of that.

Does this help though?
The problem statement remains:
(using foo)
(using bar)
x     ; what is x?

http://www.cs.nott.ac.uk/~pszgmh/appsem-papers/lagorio.pdf


)


This is too complicated for such a simple feature.
The goal was: avoid typing "primitives.+" .

