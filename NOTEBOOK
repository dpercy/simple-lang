
Current most pressing need with the notebook UI:

line numbers. I can't tell which outputs go with which expressions.

impl plan?

- add line numbers to read
- add line numbers to parse
- don't just print the line numbers - that would break all the tests
- don't add new "modes" to codegen

What do you generate for the module?
Different "runtime modes", where some env var determines how to print?

Or maybe the module doesn't run for side effects, but exports some interface
to run the module?


Maybe SL modules should be compiled down to a JS function.
That way the SL runtime has more control.
Also fits the philosophy of "everything is a value".

Its arguments would be the instantiated modules it depends on.
It returns an "instantiated module".
(function ({ bool, list, string }) {

  ...

  return {
    $gen_program,
    $parse_program,
    $read_all,
    ...
  }

});

ok, problems still:
- no incremental progress (YAGNI???)





backing up:
what problem am I solving?
- line numbers
- preserve incremental output
- preserve current behavior of command line tests?
  - or, is it more valuable to change the tests,
    so that line numbers get tested?

Simplest thing that works:
- add line numbers to read, parse
- gen line numbers in calls to "toplevel"
- let primitives.mjs read some global setting, on window, about how to print



================================================================================

I want to solve line numbers without adding tech debt.

The problem is:
the run-time behavior of a module is too fixed.
The .mjs files are too imperative:
they spit out values sequentially to console.log.

I want the compiled .mjs files to assume a bit less.
The runtime system needs more choice over what to do with the module.


At a minimum, the runtime system needs to choose:
- whether defvals get printed
- what to do with line numbers
- what to do with the strings we want to print

Ideally I don't just want to expose a flag.
Maybe I'll expose a hook.
Would be neat to turn it rightside out: yield intermediate results?


================================================================================


Next problem: no results are printed until the whole module terminates.

Web Workers would probably fix this.
But, browsers apparently don't support es6 modules in web workers yet.
So I need to either:
- compile directly to some other format instead of mjs
  - but does any format support both nodejs and browsers?
- use webpack/rollup to convert .mjs to browser files
- use a module loader inside the worker


What if I compiled each definition in a module to a promise?
It's legal to use await inside a promise, so they could just await each other.

(def x (+ 2 3))
(def y (* x x))

=>

const x = new Promise(async function(resolve) { return (  (await import "+")(2, 3)  ) })
const y = new Promise(async function(resolve) { return (  (await import "*")(await x, await x) ); })


pro:
- can use es6 modules
con:
- have to use annoying promises



Another idea:
compile to some dumb format with just JS values,
similar to (identical to?) AMD.

{
    requires: ['thing.sl', 'foo.sl'],
    provides: ['x', 'y'],
    run: function({ thing, foo }) {
        // thing and foo are the *return values* of running that corresponding module.

        const x = toplevel(() => 2 + 3);
        const y = toplevel(() => x * x);
        return { x, y };
    }
}

In this impl, a module is a value.
This might also help with `import *` type of thing.

The "runtime system" would be a separate thing that invokes the `run` method.
verbosity / control




