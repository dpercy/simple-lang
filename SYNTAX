
# comments start with a hash/sharp sign

# value defs use an equals sign
input = "L1, L5, ..."

# struct defs show an example constructor
struct Posn(x, y)

# function defs use math-like syntax
add(v, w) = ...

# an identifier can be "letter-like" or "punctuation-like".
# "punctuation-like" identifiers are used as infix,
# with NO precedence rules
hypotenuse(a, b) = sqrt((a * a) + (b * b))


# match is the most complicated type of expression.
# but the idea is you have a TABLE.
# remember it's permissible for newlines to be significant!

mag(v) = match v
 case Posn(x, y) => hypotenuse(x, y)

mag(Posn(x, y)) where x < 5 = hypotenuse(x, y)


add(Posn(x1, y1), Posn(x2, y2)) = Posn(x1 + x2, y1 + y2)

# bad repetition
turnLeft("N") = "W"
turnLeft("W") = "S"
turnLeft("S") = "E"
turnLeft("E") = "N"


# good: input/output table
turnLeft(heading) = match heading
  case "N" => "W"
  case "W" => "S"
  case "S" => "E"
  case "E" => "N"


def :=
| id = expr
| id ( id , ... ) = expr
| struct id ( id , ... )

expr :=
| literal
| id
| expr ( expr , ... )
| match arm ...

arm :=
| case pat => expr

ambiguity: similar to "else" problem:

match outer
case 1 => match inner
          case 11 => 11
          case 22 => 22
match outer
case 1 => match inner
          case 11 => 11
case 22 => 22

so this is bad because I don't want significant indentation.
what if you used braces to disambiguate?

match outer {
  case 1 => match inner {
              case 11 => 11
              case 22 => 22
            }
}


what if the braces were only required when there's an ambiguity?
- good: less syntactic noise
- bad: less syntactic consistency
- bad: the parser has to be smart enough to tell you which match needs the braces added



def :=
| id = expr0
| id ( id , ... ) = expr0
| struct id ( id , ... )

expr0 :=
| expr1 op expr1

expr1 :=
| literal
| id
| expr1 ( expr0 , ... )     -- match { ... }()
| match { arm ... }

arm :=
| case pat => expr0



But then again I kind of like Scheme's function call syntax:

(User "david" 73 "python")
  over
User("david", 73, "python")

- shorter
- less punctuation
- parens group the callee with the arguments in a little ravioli package




def :=
| id = expr0
| ( expr expr ... ) = expr0
| struct (id id ... )

expr :=
| literal
| id
| ( expr expr ... )
| ( expr op expr )    -- no precedence
| match { arm ... }

arm :=
| case pat => expr0


The downside is this is unconventional syntax.