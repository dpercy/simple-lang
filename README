
Pure Functional Programming experiment:

- Every expression must either:
    - evaluate to a value
    - diverge
    - crash

- Goal 1: notebook
    - DONE free-form like ipython
    - DONE consistent like a spreadsheet
    - DONE output shows each def/expr as "done", "running", or "crashed"



- Goal 2: alt backends
    - expandable debug trace
    - JS
    - asm.js or Webassembly
    - GLSL


  Implementation approach:
    - have:  Racket interp: SL
        - ~600 lines
    - want:  __ compile: SL to: JS              # avoid an eval server
    - want:  JS compile: SL to: JS              # avoid a compile server
    - want:  JS compile: SL to: Stream[Expr]    # debug with no eval/compile server


    steps:
    A: write a #lang for SL
      - parse strictly - don't just allow any old Racket code
      - include #' for conveniently writing syntax
        - or not? write parser in object language too.

      - how do modules work? and qualified names?
        how about the roughly-Java way of doing it:
	- can use fq names without imports
	- imports just abbreviate names
	- the compiler can syntactically determine which modules you depend on,
	  just by looking at every identifier


      - prims?
        - no. only structs.

    B(A): write an SL to JS compiler in SL
      - include faithful errors?

    C(A): write an SL interpreter in SL

    






- Goal 3: conventional syntax
    - infix math
    - conventional f(x, y) function calls
    - infix "=" for definitions

    - implementing this parser in the lang itself would
      avoid having to reimplement it
  