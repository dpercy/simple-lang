
Pure Functional Programming experiment:

- Every expression must either:
    - evaluate to a value
    - diverge
    - crash

- Goal 1: notebook
    - DONE free-form like ipython
    - DONE consistent like a spreadsheet
    - DONE output shows each def/expr as "done", "running", or "crashed"
    
  - practicality:
    - DONE convenient syntax for naturals and strings (and lists?)
    - DONE jets or primops for manipulating them
    - (maybe later) would be neat if this was semantically just sugar for constructors

  - DONE saving
    - I need a way to save the buffer somewhere
    - also a way to open files later
    - simple version: drag and drop?

  - better semantics
    - prototype relies too much on Racket side effects

  - inline output
    - each statement's result should go under the appropriate line
    - can ignore defs
    - errors should look different from values

  - local definitions
    - just "let" would be ok

  - prove it! by doing advent of code
    - work slowly
    - create tickets
    - save my work

  - robustness:
    - edits made in one definition should not invalidate other defs.
      - DONE MEMO APPROACH: break evaluation into several steps, and memoize some of them:
        - (program, def) -> (reachable-program, def)  ; remove statements irrelevant to *this def*
	  - cheap; no need to memoize.
	- (reachable-program, def) -> process ;
	  - memoize this by value!
	  - if the def changed, or a dep changed, the result changes.
	  - expire policy for memo table??
	    - really big lru cache for now
	  - if 
      - DIFF APPROACH: let eval-program look at 2 versions
        - goal is to return the eval of the new version
	- but can reuse previous results when possible
	- specifically, each new STMT can use its old value if all its (transitively) reachable deps are unchanged

    
    - TODO paren edits should not bork other definitions' parsing
      - hack version: break input at each toplevel indentation

    - TODO avoid polling in in-rendered-evaluation

    - TODO avoid leaking threads that don't terminate
      - try suspending all threads in the old state,
        then resuming in the new state,
	then letting the old state become unreachable.
	because "A thread that has not terminated can be garbage collected (see Garbage Collection) if it is unreachable and suspended"
	https://docs.racket-lang.org/reference/threads.html



- Goal 2: alt backends
    - expandable debug trace
    - JS
    - asm.js or Webassembly
    - GLSL
- 
