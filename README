
Total Functional Programming experiment:

- Every valid expression must evaluate to a value.
    - The system must reject any program that doesn't halt.
    - Unfortunately this means the system will reject some valid programs too.

- Many evaluation strategies are possible:
    - A naive tree rewriter (which could also work on open terms)
    - Transliterate to a strict untyped language (Scheme or JS)
    - Compile to a GC-free subset of JS or Webassembly (certain types only)
    - Compile to GLSL (certain types only)


TODO list:

rough implementation:
- parsing/printing
    - DONE parse
    - pretty-print
- totality checker - 4 components:
    - well-formed types checker
    - typechecker
    - case coverage checker (prevents crashing)
    - termination checker (recursive args must decrease)
- rewrite-based evaluator


- trace viewer
    - like "resugaring", except instead of macros we have normal function calls
    - map f [1,2,3]  steps immediately to  [f 1, f 2, f 3]  if we hide map
        - even if map is defined in terms of fold


- notebook
    - constantly recompute the type and value of every def (and expr)
    - don't let a bad def prevent you from checking/running other defs
        - this means all static checks (typechecking, case coverage, well-founded-recursion)
	  must mark individual definitions as failed instead of the whole program.


- JS evaluator
    - try representing Nat as a plain integer
        - on overflow, crash
            - every implementation must either match the semantics,
              or fail.
            - failure is not part of the semantics,
              but is an unavoidable part of some machines.


- make some simple animations and games
    - try doing FRP (Conal Eliott style), but use Floats...?
        - proof that rationals aren't enough: (getX (normalize (vec2 1 1))) ==  1/(sqrt 2)
	- continued fractions probably use too much space
	- is there a way to use floats but still get the right answer?
	    - maybe if a number is destined for the screen, precision doesn't matter
	    - only if a number is destined for some stark comparison (event defined as predicate on behavior)
	      does it matter to get precisely the right answer
                - problem is collisions are ubiquitous
	- OR, make rounding explicit?
	    - operations like sqrt would return a true "real", which isn't representable on some machines.
	    - you would explicitly round to the nearest float, or nearest nth continued fraction or whatever.
	    - algebra would make sense because the explicit rounding would explain why things don't commute, etc.


- language features
    - typeclasses (or polytypic functions??)
        - necessary for safe generic equality, sorting, etc
	- useful for sequencing operators for different types of actions
	- 